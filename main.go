// search.
package main

import (
	"context"
	"encoding/base64"
	"fmt"
	"io/ioutil"
	"log"
	"time"

	"github.com/chromedp/cdproto/cdp"
	//"github.com/chromedp/cdproto/emulation"
	"github.com/chromedp/chromedp"

	chrome "github.com/mkenney/go-chrome/tot"
	"github.com/mkenney/go-chrome/tot/cdtp/emulation"
	"github.com/mkenney/go-chrome/tot/cdtp/page"
)

func main2() {
	var err error

	// create context
	ctxt, cancel := context.WithCancel(context.Background())
	defer cancel()

	// create chrome instance
	c, err := chromedp.New(ctxt, chromedp.WithLog(log.Printf))
	if err != nil {
		log.Fatal(err)
	}

	// run task list
	var site, res string
	//err = c.Run(ctxt, googleSearch("site:brank.as", "Home", &site, &res))
	err = c.Run(ctxt, skyscannerSearch())
	if err != nil {
		log.Fatal(err)
	}

	// shutdown chrome
	err = c.Shutdown(ctxt)
	if err != nil {
		log.Fatal(err)
	}

	// wait for chrome to finish
	err = c.Wait()
	if err != nil {
		log.Fatal(err)
	}

	log.Printf("saved screenshot from search result listing `%s` (%s)", res, site)
}

func googleSearch(q, text string, site, res *string) chromedp.Tasks {
	var buf []byte
	sel := fmt.Sprintf(`//a[text()[contains(., '%s')]]`, text)
	fmt.Println(sel)
	fmt.Println("=======================")
	return chromedp.Tasks{
		chromedp.Navigate(`https://www.google.com`),
		chromedp.WaitVisible(`span.fqs-price`, chromedp.ByID),
		chromedp.SendKeys(`#lst-ib`, q+"\n", chromedp.ByID),
		chromedp.WaitVisible(`#res`, chromedp.ByID),
		chromedp.Text(sel, res),
		chromedp.Click(sel),
		chromedp.WaitNotVisible(`.preloader-content`, chromedp.ByQuery),
		chromedp.WaitVisible(`a[href*="twitter"]`, chromedp.ByQuery),
		chromedp.Location(site),
		chromedp.ScrollIntoView(`.banner-section.third-section`, chromedp.ByQuery),
		chromedp.Sleep(2 * time.Second), // wait for animation to finish
		chromedp.Screenshot(`.banner-section.third-section`, &buf, chromedp.ByQuery),
		chromedp.ActionFunc(func(context.Context, cdp.Executor) error {
			return ioutil.WriteFile("screenshot.png", buf, 0644)
		}),
	}
}
func skyscannerSearch() chromedp.Tasks {
	var buf []byte
	return chromedp.Tasks{
		chromedp.Navigate(`https://www.skyscanner.net/transport/flights/mdea/syda/180801/?adults=1&children=0&adultsv2=1&childrenv2=&infants=0&cabinclass=economy&rtn=0&preferdirects=false&outboundaltsenabled=false&inboundaltsenabled=false&ref=home#results`),
		chromedp.WaitVisible(`span.fqs-price`),
		chromedp.ActionFunc(func(context.Context, cdp.Executor) error {
			log.Printf(">>>>>>>>>>>>>>>>>>>> BOX1 IS VISIBLE")
			return nil
		}),
		chromedp.Screenshot(`span.fqs-price`, &buf, chromedp.ByQuery),
		chromedp.ActionFunc(func(context.Context, cdp.Executor) error {
			return ioutil.WriteFile("screenshot.png", buf, 0644)
		}),
	}
}

func main() {
	var err error

	// Define a chrome instance with remote debugging enabled.
	browser := chrome.New(
		// See https://developers.google.com/web/updates/2017/04/headless-chrome#cli
		// for details about startup flags
		&chrome.Flags{
			"addr":               "localhost",
			"disable-extensions": nil,
			"disable-gpu":        nil,
			"headless":           nil,
			"hide-scrollbars":    nil,
			"no-first-run":       nil,
			"no-sandbox":         nil,
			"port":               9222,
			"remote-debugging-address": "0.0.0.0",
			"remote-debugging-port":    9222,
		},
		"/usr/bin/google-chrome", // Path to Chromeium binary
		"/tmp",      // Set the Chromium working directory
		"/dev/null", // Ignore internal Chromium output, set to empty string for os.Stdout
		"/dev/null", // Ignore internal Chromium errors, set to empty string for os.Stderr
	)

	// Start the chrome process.
	if err := browser.Launch(); nil != err {
		panic(err)
	}

	// Open a tab and navigate to the URL you want to screenshot.
	tab, err := browser.NewTab("https://www.google.com")
	if nil != err {
		panic(err)
	}

	// Enable Page events for this tab.
	if enableResult := <-tab.Page().Enable(); nil != enableResult.Err {
		panic(enableResult.Err)
	}

	// Create a channel to receive the screenshot data generated by the
	// event handler.
	results := make(chan *page.CaptureScreenshotResult)

	// Create an event handler that will execute when the page load event
	// fires with a closure that will capture the screenshot and write
	// the result to the results channel. This can also be done manually
	// via:
	//	eventHandler := socket.NewEventHandler(
	//		"Page.loadEventFired",
	//		func(response *socket.Response) {
	//			...
	//			results <- screenshotResult
	//		},
	//	)
	//	tab.AddEventHandler(eventHandler)
	tab.Page().OnLoadEventFired(
		// This function will generate a screenshot and write the data
		// to the results channel.
		func(event *page.LoadEventFiredEvent) {

			// Set the device emulation parameters.
			overrideResult := <-tab.Emulation().SetDeviceMetricsOverride(
				&emulation.SetDeviceMetricsOverrideParams{
					Width:  1440,
					Height: 1440,
					ScreenOrientation: &emulation.ScreenOrientation{
						Type:  emulation.OrientationType.PortraitPrimary,
						Angle: 90,
					},
				},
			)
			if nil != overrideResult.Err {
				panic(overrideResult.Err)
			}

			// Capture a screenshot of the current state of the current
			// page.
			screenshotResult := <-tab.Page().CaptureScreenshot(
				&page.CaptureScreenshotParams{
					Format:  page.Format.Jpeg,
					Quality: 50,
				},
			)
			if nil != screenshotResult.Err {
				panic(screenshotResult.Err)
			}

			results <- screenshotResult
		},
	)

	// Wait for the handler to fire
	result := <-results

	// Decode the base64 encoded image data
	data, err := base64.StdEncoding.DecodeString(result.Data)
	if nil != err {
		panic(err)
	}

	// Write the generated image to a file
	err = ioutil.WriteFile("example.jpg", data, 0644)
	if nil != err {
		panic(err)
	}

	fmt.Println("Finished rendering example.jpg")
}
